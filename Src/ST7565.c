/*
$Id:$

ST7565 LCD library!

Copyright (C) 2010 Limor Fried, Adafruit Industries

This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation; either
version 2.1 of the License, or (at your option) any later version.

This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with this library; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA

// some of this code was written by <cstone@pobox.com> originally; it is in the public domain.
*/

#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include "ST7565.h"

#define ST7565_STARTBYTES 4

/*----------------------------data----------------------------*/







uint8_t is_reversed = 0;

// a handy reference to where the pages are on the screen
//const uint8_t pagemap[] = { 3, 2, 1, 0, 7, 6, 5, 4 };
const uint8_t pagemap[] = { 7, 6, 5, 4, 3, 2, 1, 0 };

// a 5x7 font table
extern const uint8_t font[];

// the memory buffer for the LCD
uint8_t st7565_buffer[1024] = { 
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
/*uint8_t st7565_buffer[1024] = {
 0x00, 0x07, 0x18, 0x20, 0x20, 0x40, 0x40, 0x40, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x40, 0x40, 0x40, 0x20, 0x20, 0x18, 0x07, 0x00, 
 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff,
 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff,
 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff,
 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff,
 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff,
 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff,
 0x00, 0xe0, 0x18, 0x04, 0x04, 0x02, 0x02, 0x02, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x04, 0x04, 0x18, 0xe0, 0x00};
*/

/*----------------------------END_data----------------------------*/

// reduces how much is refreshed, which speeds it up!
// originally derived from Steve Evans/JCW's mod but cleaned up and
// optimized
//#define enablePartialUpdate

#ifdef enablePartialUpdate
static uint8_t xUpdateMin, xUpdateMax, yUpdateMin, yUpdateMax;
#endif

/*----------------------------functions----------------------------*/

static void ST7565_updateBoundingBox(ST7565R_Settings* settings, uint8_t xmin, uint8_t ymin, uint8_t xmax, uint8_t ymax) {
#ifdef enablePartialUpdate
  if (xmin < xUpdateMin) xUpdateMin = xmin;
  if (xmax > xUpdateMax) xUpdateMax = xmax;
  if (ymin < yUpdateMin) yUpdateMin = ymin;
  if (ymax > yUpdateMax) yUpdateMax = ymax;
#endif
}

void ST7565_drawbitmap(ST7565R_Settings* settings, uint8_t x, uint8_t y, const uint8_t *bitmap, uint8_t w, uint8_t h, uint8_t color) {
  uint8_t i, j;
  for (j=0; j<h; j++) {
    for (i=0; i<w; i++ ) {
      if (bitmap[i + (j/8) * w] & (1<<(j%8))) {
        ST7565_my_setpixel(settings, x+i, y+j, color);
      }
    }
  }

  ST7565_updateBoundingBox(settings, x, y, x+w, y+h);
}

void ST7565_drawstring_line(ST7565R_Settings* settings, uint8_t x, uint8_t line, char *c) {
  while (c[0] != 0) {
	ST7565_drawchar_line(settings, x, line, c[0]);
    c++;
    x += 6; // 6 pixels wide
    if (x + 6 >= LCDWIDTH) {
      x = 0;    // ran out of this line
      line++;
    }
    if (line >= (LCDHEIGHT/8))
      return;        // ran out of space :(
  }
}

void ST7565_drawstring_pixel(ST7565R_Settings* settings, uint8_t x, uint8_t y, char *c) {
  if(y%8 == 0){
    ST7565_drawstring_line(settings, x, y/8, c);
    return;
  }

  while (c[0] != 0) {
	ST7565_drawchar_pixel(settings, x, y, c[0]);
    c++;
    x += 6; // 6 pixels wide
    if (x + 6 >= LCDWIDTH) {
      x = 0; // ran out of this line
      y += 8;
    }
    if (y >= LCDHEIGHT)
      return;        // ran out of space :(
  }
}

void ST7565_drawstring_P_line(ST7565R_Settings* settings, uint8_t x, uint8_t line, const char *str) {
  char c;
  while (1) {
    c = *str++;
    if (! c)
      return;
    ST7565_drawchar_line(settings, x, line, c);
    x += 6; // 6 pixels wide
    if (x + 6 >= LCDWIDTH) {
      x = 0;    // ran out of this line
      line++;
    }
    if (line >= (LCDHEIGHT/8))
      return;        // ran out of space :(
  }
}

void ST7565_drawstring_P_pixel(ST7565R_Settings* settings, uint8_t x, uint8_t y, const char *str) {
  if(y%8 == 0){
	  ST7565_drawstring_P_line(settings, x, y/8, str);
	  return;
  }

  char c;
  while (1) {
    c = *str++;
    if (! c)
      return;
    ST7565_drawchar_pixel(settings, x, y, c);
    x += 6; // 6 pixels wide
    if (x + 6 >= LCDWIDTH) {
      x = 0;    // ran out of this line
      y += 8;
    }
    if (y >= LCDHEIGHT)
      return;        // ran out of space :(
  }
}

void  ST7565_drawchar_line(ST7565R_Settings* settings, uint8_t x, uint8_t line, char c) {
  uint8_t i;
  for (i =0; i<5; i++ ) {
    st7565_buffer[x + (line*128) ] = font[((unsigned char)c * 5) + i];
    x++;
  }

  ST7565_updateBoundingBox(settings, x-5, line*8, x-1, line*8 + 8);
}

void  ST7565_drawchar_pixel(ST7565R_Settings* settings, uint8_t x, uint8_t y, char c) {
  uint8_t i;
  uint8_t y1, y2, a, b;
  a = y%8;
  b = y/8;
  if(a==0)
	  ST7565_drawchar_line(settings, x, b, c);
  else{
	  for (i =0; i<5; i++ ) {
		  y1 = ST7565_getbuffunit(settings, x, b) & (0xff << (8-a));
		  y2 = ST7565_getbuffunit(settings, x, b+1) & (0xff >> a);
		  y1 |= font[((unsigned char)c * 5) + i] >> a;
		  y2 |= font[((unsigned char)c * 5) + i] << (8-a);
		  ST7565_setbuffunit(settings, x, b, y1);
		  ST7565_setbuffunit(settings, x, b+1, y2);
	      x++;
	  }
  }
}

// bresenham's algorithm - thx wikpedia
void ST7565_drawline(ST7565R_Settings* settings, uint8_t x0, uint8_t y0, uint8_t x1, uint8_t y1,
		      uint8_t color) {
  uint8_t steep = abs(y1 - y0) > abs(x1 - x0);
  if (steep) {
    swap(x0, y0);
    swap(x1, y1);
  }

  if (x0 > x1) {
    swap(x0, x1);
    swap(y0, y1);
  }

  // much faster to put the test here, since we've already sorted the points
  ST7565_updateBoundingBox(settings, x0, y0, x1, y1);

  uint8_t dx, dy;
  dx = x1 - x0;
  dy = abs(y1 - y0);

  int8_t err = dx / 2;
  int8_t ystep;

  if (y0 < y1) {
    ystep = 1;
  } else {
    ystep = -1;}

  for (; x0<=x1; x0++) {
    if (steep) {
    	ST7565_my_setpixel(settings, y0, x0, color);
    } else {
    	ST7565_my_setpixel(settings, x0, y0, color);
    }
    err -= dy;
    if (err < 0) {
      y0 += ystep;
      err += dx;
    }
  }
}

// filled rectangle
void ST7565_fillrect(ST7565R_Settings* settings, uint8_t x, uint8_t y, uint8_t w, uint8_t h, uint8_t color) {
  uint8_t i, j;

  // stupidest version - just pixels - but fast with internal buffer!
  for (i=x; i<x+w; i++) {
    for (j=y; j<y+h; j++) {
      ST7565_my_setpixel(settings, i, j, color);
    }
  }

  ST7565_updateBoundingBox(settings, x, y, x+w, y+h);
}

// draw a rectangle
void ST7565_drawrect(ST7565R_Settings* settings, uint8_t x, uint8_t y, uint8_t w, uint8_t h, uint8_t color) {
  uint8_t i;
  // stupidest version - just pixels - but fast with internal buffer!
  for (i=x; i<x+w; i++) {
	ST7565_my_setpixel(settings, i, y, color);
	ST7565_my_setpixel(settings, i, y+h-1, color);
  }
  for (i=y; i<y+h; i++) {
	ST7565_my_setpixel(settings, x, i, color);
	ST7565_my_setpixel(settings, x+w-1, i, color);
  } 

  ST7565_updateBoundingBox(settings, x, y, x+w, y+h);
}

// draw a circle outline
void ST7565_drawcircle(ST7565R_Settings* settings, uint8_t x0, uint8_t y0, uint8_t r, uint8_t color) {
	ST7565_updateBoundingBox(settings, x0-r, y0-r, x0+r, y0+r);

  int8_t f = 1 - r;
  int8_t ddF_x = 1;
  int8_t ddF_y = -2 * r;
  int8_t x = 0;
  int8_t y = r;

  ST7565_my_setpixel(settings, x0, y0+r, color);
  ST7565_my_setpixel(settings, x0, y0-r, color);
  ST7565_my_setpixel(settings, x0+r, y0, color);
  ST7565_my_setpixel(settings, x0-r, y0, color);

  while (x<y) {
    if (f >= 0) {
      y--;
      ddF_y += 2;
      f += ddF_y;
    }
    x++;
    ddF_x += 2;
    f += ddF_x;
  
    ST7565_my_setpixel(settings, x0 + x, y0 + y, color);
    ST7565_my_setpixel(settings, x0 - x, y0 + y, color);
    ST7565_my_setpixel(settings, x0 + x, y0 - y, color);
    ST7565_my_setpixel(settings, x0 - x, y0 - y, color);
    
    ST7565_my_setpixel(settings, x0 + y, y0 + x, color);
    ST7565_my_setpixel(settings, x0 - y, y0 + x, color);
    ST7565_my_setpixel(settings, x0 + y, y0 - x, color);
    ST7565_my_setpixel(settings, x0 - y, y0 - x, color);
    
  }



}

void ST7565_fillcircle(ST7565R_Settings* settings, uint8_t x0, uint8_t y0, uint8_t r, uint8_t color) {
  ST7565_updateBoundingBox(settings, x0-r, y0-r, x0+r, y0+r);

  int8_t f = 1 - r;
  int8_t ddF_x = 1;
  int8_t ddF_y = -2 * r;
  int8_t x = 0;
  int8_t y = r;
  uint8_t i;

  for (i=y0-r; i<=y0+r; i++) {
	ST7565_my_setpixel(settings, x0, i, color);
  }

  while (x<y) {
    if (f >= 0) {
      y--;
      ddF_y += 2;
      f += ddF_y;
    }
    x++;
    ddF_x += 2;
    f += ddF_x;
  
    for (i=y0-y; i<=y0+y; i++) {
      ST7565_my_setpixel(settings, x0+x, i, color);
      ST7565_my_setpixel(settings, x0-x, i, color);
    } 
    for (i=y0-x; i<=y0+x; i++) {
      ST7565_my_setpixel(settings, x0+y, i, color);
      ST7565_my_setpixel(settings, x0-y, i, color);
    }    
  }
}

void ST7565_my_setpixel(ST7565R_Settings* settings, uint8_t x, uint8_t y, uint8_t color) {
  if ((x >= LCDWIDTH) || (y >= LCDHEIGHT))
    return;

  // x is which column
  if (color) 
    st7565_buffer[x+ (y/8)*128] |= (1<<(7-(y%8)));
  else
    st7565_buffer[x+ (y/8)*128] &= ~(1<<(7-(y%8)));
}

// the most basic function, set a single pixel
void ST7565_setpixel(ST7565R_Settings* settings, uint8_t x, uint8_t y, uint8_t color) {
  if ((x >= LCDWIDTH) || (y >= LCDHEIGHT))
    return;

  // x is which column
  if (color) 
    st7565_buffer[x+ (y/8)*128] |= (1<<(7-(y%8)));
  else
    st7565_buffer[x+ (y/8)*128] &= ~(1<<(7-(y%8)));

  ST7565_updateBoundingBox(settings, x,y,x,y);
}

// the most basic function, get a single pixel
uint8_t ST7565_getpixel(ST7565R_Settings* settings, uint8_t x, uint8_t y) {
  if ((x >= LCDWIDTH) || (y >= LCDHEIGHT))
    return 0;

  return (st7565_buffer[x+ (y/8)*128] >> (7-(y%8))) & 0x1;  
}

uint8_t ST7565_getbuffunit(ST7565R_Settings* settings, uint8_t x, uint8_t line) {
  if ((x >= LCDWIDTH) || (line >= LCDHEIGHT / 8))
    return 0;

  return st7565_buffer[x + (line*128) ];
}

void ST7565_setbuffunit(ST7565R_Settings* settings, uint8_t x, uint8_t line, uint8_t data) {
  if ((x >= LCDWIDTH) || (line >= LCDHEIGHT / 8))
    return;
  else
	  st7565_buffer[x + (line*128) ] = data;
}

void ST7565_begin(ST7565R_Settings* settings, uint8_t contrast) {
	Fifo_Err errors;

	list_create(&(settings->buffer), &errors);
	ST7565_st7565_init(settings);
	ST7565_st7565_command(settings, CMD_DISPLAY_ON);
	ST7565_st7565_command(settings, CMD_SET_ALLPTS_NORMAL);
	ST7565_st7565_set_brightness(settings, contrast);
}

void ST7565_st7565_init(ST7565R_Settings* settings) {
  // set pin directions
//  pinMode(sid, OUTPUT);
//  pinMode(sclk, OUTPUT);
//  pinMode(a0, OUTPUT);
//  pinMode(rst, OUTPUT);
//  pinMode(cs, OUTPUT);

  // toggle RST low to reset; CS low so it'll listen to us
//  if (cs > 0)
//    digitalWrite(cs, LOW);
	HAL_GPIO_WritePin(settings->IOcs.PORT, settings->IOcs.PIN, GPIO_PIN_RESET);

//  digitalWrite(rst, LOW);
	HAL_GPIO_WritePin(settings->IOrst.PORT, settings->IOrst.PIN, GPIO_PIN_RESET);
	HAL_Delay(500);

//  digitalWrite(rst, HIGH);
	HAL_GPIO_WritePin(settings->IOrst.PORT, settings->IOrst.PIN, GPIO_PIN_SET);

  // LCD bias select
  ST7565_st7565_command(settings, CMD_SET_BIAS_7);
  // ADC select
  ST7565_st7565_command(settings, CMD_SET_ADC_NORMAL);
  // SHL select
  ST7565_st7565_command(settings, CMD_SET_COM_NORMAL);
  // Initial display line
  ST7565_st7565_command(settings, CMD_SET_DISP_START_LINE);

  // turn on voltage converter (VC=1, VR=0, VF=0)
  ST7565_st7565_command(settings, CMD_SET_POWER_CONTROL | 0x4);
  // wait for 50% rising
  HAL_Delay(50);

  // turn on voltage regulator (VC=1, VR=1, VF=0)
  ST7565_st7565_command(settings, CMD_SET_POWER_CONTROL | 0x6);
  // wait >=50ms
  HAL_Delay(50);

  // turn on voltage follower (VC=1, VR=1, VF=1)
  ST7565_st7565_command(settings, CMD_SET_POWER_CONTROL | 0x7);
  // wait
  HAL_Delay(10);

  // set lcd operating voltage (regulator resistor, ref voltage resistor)
  ST7565_st7565_command(settings, CMD_SET_RESISTOR_RATIO | 0x6);

  // initial display line
  // set page address
  // set column address
  // write display data

  // set up a bounding box for screen updates

  ST7565_updateBoundingBox(settings, 0, 0, LCDWIDTH-1, LCDHEIGHT-1);
}

inline void ST7565_spiwrite(ST7565R_Settings* settings) {
  //shiftOut(sid, sclk, MSBFIRST, c);
  //while (SPI_GetFlagStatus(SPI2, SPI_FLAG_TXE) == RESET);
	Fifo_Err errors;

	DataToST7565* data = (DataToST7565*)list_front(settings->buffer, &errors);
	HAL_GPIO_WritePin(settings->IOa0.PORT, settings->IOa0.PIN, data->state_a0);

	HAL_SPI_Transmit_IT(settings->spi, &(data->val), 1); //SPI_SendData(SPI2, c);
}

void ST7565_st7565_command(ST7565R_Settings* settings, uint8_t c) {
	Fifo_Err errors;

	__disable_irq();
	DataToST7565* data = (DataToST7565*)malloc(sizeof(DataToST7565));
	__enable_irq();
	data->state_a0 = false;
	data->val = c;
	list_push_NC(settings->buffer, data, &errors);
	if(list_getSize(settings->buffer, &errors) <= 1)
		ST7565_spiwrite(settings);

	//HAL_GPIO_WritePin(lcd.IOa0.PORT, lcd.IOa0.PIN, GPIO_PIN_RESET);

	//ST7565_spiwrite(c);
}

void ST7565_st7565_data(ST7565R_Settings* settings, uint8_t c) {
	Fifo_Err errors;

	__disable_irq();
	DataToST7565* data = (DataToST7565*)malloc(sizeof(DataToST7565));
	__enable_irq();
	data->state_a0 = true;
	data->val = c;
	list_push_NC(settings->buffer, data, &errors);
	if(list_getSize(settings->buffer, &errors) <= 1)
			ST7565_spiwrite(settings);

	//HAL_GPIO_WritePin(lcd.IOa0.PORT, lcd.IOa0.PIN, GPIO_PIN_SET);

	//ST7565_spiwrite(c);
}

void ST7565_st7565_set_brightness(ST7565R_Settings* settings, uint8_t val) {
	ST7565_st7565_command(settings, CMD_SET_VOLUME_FIRST);
    ST7565_st7565_command(settings, CMD_SET_VOLUME_SECOND | (val & 0x3f));
}


void ST7565_display(ST7565R_Settings* settings) {
  uint8_t col, maxcol, p;

  /*
  Serial.print("Refresh ("); Serial.print(xUpdateMin, DEC); 
  Serial.print(", "); Serial.print(xUpdateMax, DEC);
  Serial.print(","); Serial.print(yUpdateMin, DEC); 
  Serial.print(", "); Serial.print(yUpdateMax, DEC); Serial.println(")");
  */

  for(p = 0; p < 8; p++) {
    /*
      putstring("new page! ");
      uart_putw_dec(p);
      putstring_nl("");
    */
#ifdef enablePartialUpdate
    // check if this page is part of update
    if ( yUpdateMin >= ((p+1)*8) ) {
      continue;   // nope, skip it!
    }
    if (yUpdateMax < p*8) {
      break;
    }
#endif

    HAL_Delay(1);
    ST7565_st7565_command(settings, CMD_SET_PAGE | pagemap[p]);
    HAL_Delay(1);//DelayuS(100);


#ifdef enablePartialUpdate
    col = xUpdateMin;
    maxcol = xUpdateMax;
#else
    // start at the beginning of the row
    col = 0;
    maxcol = LCDWIDTH;
#endif

    ST7565_st7565_command(settings, CMD_SET_COLUMN_LOWER | ((col+ST7565_STARTBYTES) & 0xf));
    HAL_Delay(1);
    ST7565_st7565_command(settings, CMD_SET_COLUMN_UPPER | (((col+ST7565_STARTBYTES) >> 4) & 0x0F));
    HAL_Delay(1);
    ST7565_st7565_command(settings, CMD_RMW);
    HAL_Delay(1);//DelayuS(100);
    
    for(; col < maxcol; col++) {
      //uart_putw_dec(col);
      //uart_putchar(' ');
      ST7565_st7565_data(settings, st7565_buffer[(128*p)+col]);
      //DelayuS(10);
    }
  }

#ifdef enablePartialUpdate
  xUpdateMin = LCDWIDTH;// - 1;
  xUpdateMax = 0;
  yUpdateMin = LCDHEIGHT;//-1;
  yUpdateMax = 0;
#endif
}

// clear everything
void ST7565_clear(ST7565R_Settings* settings) {
  memset(st7565_buffer, 0, 1024);
  ST7565_updateBoundingBox(settings, 0, 0, LCDWIDTH-1, LCDHEIGHT-1);
}


// this doesnt touch the buffer, just clears the display RAM - might be handy
void ST7565_clear_display(ST7565R_Settings* settings) {
  uint8_t p, c;
  
  for(p = 0; p < 8; p++) {
    /*
      putstring("new page! ");
      uart_putw_dec(p);
      putstring_nl("");
    */

	ST7565_st7565_command(settings, CMD_SET_PAGE | p);
    for(c = 0; c < 128; c++) {
      //uart_putw_dec(c);
      //uart_putchar(' ');
      ST7565_st7565_command(settings, CMD_SET_COLUMN_LOWER | (c & 0xf));
      ST7565_st7565_command(settings, CMD_SET_COLUMN_UPPER | ((c >> 4) & 0xf));
      //DelayuS(10);
      ST7565_st7565_data(settings, 0x0);
    }
  }
}

/*----------------------------END_functions----------------------------*/
